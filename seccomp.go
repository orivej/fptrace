//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"os"

	"github.com/orivej/e"
	sys "github.com/orivej/fptrace/syscalls"
	"golang.org/x/net/bpf"
)

const (
	SECCOMP_RET_TRACE = 0x7ff00000
	SECCOMP_RET_ALLOW = 0x7fff0000
)

var syscalls = []int64{
	sys.SYS_CHDIR,
	sys.SYS_CLOSE,
	sys.SYS_DUP,
	sys.SYS_DUP2,
	sys.SYS_DUP3,
	sys.SYS_EXECVE,
	sys.SYS_EXECVEAT,
	sys.SYS_FCHDIR,
	sys.SYS_FCNTL,
	sys.SYS_LINK,
	sys.SYS_LINKAT,
	sys.SYS_OPEN,
	sys.SYS_OPENAT,
	sys.SYS_PIPE,
	sys.SYS_PIPE2,
	sys.SYS_PREAD64,
	sys.SYS_PREADV,
	sys.SYS_PREADV2,
	sys.SYS_PWRITE64,
	sys.SYS_PWRITEV,
	sys.SYS_PWRITEV2,
	sys.SYS_READ,
	sys.SYS_READV,
	sys.SYS_RENAME,
	sys.SYS_RENAMEAT,
	sys.SYS_RENAMEAT2,
	sys.SYS_RMDIR,
	sys.SYS_UNLINK,
	sys.SYS_UNLINKAT,
	sys.SYS_WRITE,
	sys.SYS_WRITEV,
}

func syscallsOnThisArch() (available []int64) {
	for _, syscall := range syscalls {
		if syscall > sys.NOT_ON_THIS_ARCH_MAX {
			available = append(available, syscall)
		}
	}
	return
}

func main() {
	available := syscallsOnThisArch()
	n := len(available)
	p := make([]bpf.Instruction, n+3)
	p[0] = bpf.LoadAbsolute{Off: 0, Size: 4}
	p[n+1] = bpf.RetConstant{Val: SECCOMP_RET_ALLOW}
	p[n+2] = bpf.RetConstant{Val: SECCOMP_RET_TRACE}
	for i, sc := range available {
		p[i+1] = bpf.JumpIf{Cond: bpf.JumpEqual, Val: uint32(sc), SkipTrue: uint8(n - i)}
	}
	ins, err := bpf.Assemble(p)
	e.Exit(err)

	os.Stdout, err = os.Create("seccomp.h")
	e.Exit(err)
	fmt.Println("// Code generated by ./seccomp.go. DO NOT EDIT.\n")
	fmt.Println("#include <linux/filter.h>\n")
	fmt.Println("struct sock_filter seccomp_filter[] = {")
	for _, in := range ins {
		fmt.Printf("\t{%#x, %d, %d, %#x},\n", in.Op, in.Jt, in.Jf, in.K)
	}
	fmt.Println("};\n")
	fmt.Printf("struct sock_fprog seccomp_program = {%d, seccomp_filter};\n", len(ins))
}
